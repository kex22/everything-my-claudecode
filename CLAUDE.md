# everything-my-claudecode

自用 Claude Code 插件集合。

## 仓库结构

```
everything-my-claudecode/
├── plugins/
│   └── kex-dev/              ← kex 项目开发工作流插件
│       ├── .claude-plugin/   ← 插件元数据（name, version）
│       ├── commands/         ← 用户可调用的斜杠命令（/kex-dev:xxx）
│       ├── skills/           ← 技能实现（SKILL.md）
│       └── shared/           ← 跨技能共享规范
├── CLAUDE.md                 ← 本文件
└── README.md
```

## 开发规范

- 插件内容变更后必须 bump `plugin.json` 中的版本号，再 `claude plugin update` 刷新缓存
- 技能文件使用 `${CLAUDE_PLUGIN_ROOT}` 引用 shared 资源

## 技能编写经验

以下是调试技能过程中积累的 prompt engineering 模式，用于提高 AI 执行多步骤技能的可靠性。

### 1. 前置准备分离读取与输出

**问题**：步骤中混合"读文件"和"输出内容"时，模型读完文件后容易忘记输出（注意力被文件内容冲淡）。

**解法**：加 `## 前置准备` 阶段集中读取，正式步骤只消费已有信息。

```markdown
## 前置准备
1. 读取 xxx 了解规范
2. 读取 yyy 了解现状

准备完成后，依次执行以下步骤：

### 1. 输出 xxx（不再读文件，只管输出）
```

### 2. 输出锚点防跳步

**问题**：多步骤技能中，AI 容易合并多个步骤为一篇"综合回复"。开放式叙述步骤（如"用自己的话介绍"）尤其容易触发模式滑移，连带后续步骤一起被吞掉。

**解法**：给每个步骤加显式输出锚点。

- **结构化步骤**：开头加 `**先输出 "### 标题"，再开始执行。**`，强制产生输出打断合并倾向
- **开放式步骤**：提供输出模板（加粗小节标题），把"作文题"变成"填空题"

```markdown
# 反例（容易被跳过）
向用户介绍 docs/ 下三个目录的作用，用自己的话，结合项目实际。

# 正例（稳定输出）
必须输出以下三个小节（内容用自己的话，结合项目实际）：

**`docs/design/` — 设计方案（活文档）**
要点：...

**`docs/plans/` — 实施计划（执行清单）**
要点：...
```

### 3. 标题层级区分阶段

**问题**：前置准备和执行步骤使用相同标题层级（都是 `##`）时，模型难以区分阶段边界。

**解法**：前置准备用 `##`，执行步骤用 `###`，步骤内子节用 `####`。
