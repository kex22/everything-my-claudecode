# everything-my-claudecode

自用 Claude Code 插件集合。

## 仓库结构

```
everything-my-claudecode/
├── plugins/
│   └── kex-dev/              ← kex 项目开发工作流插件
│       ├── .claude-plugin/   ← 插件元数据（name, version）
│       ├── commands/         ← 用户可调用的斜杠命令（/kex-dev:xxx）
│       ├── skills/           ← 技能实现（SKILL.md）
│       └── shared/           ← 跨技能共享规范
├── CLAUDE.md                 ← 本文件
└── README.md
```

## 开发规范

- 插件内容变更后必须 bump `plugin.json` 中的版本号，再 `claude plugin update` 刷新缓存
- 技能文件使用 `${CLAUDE_PLUGIN_ROOT}` 引用 shared 资源

## 技能编写经验

以下是调试技能过程中积累的 prompt engineering 模式，用于提高 AI 执行多步骤技能的可靠性。

### 1. 前置准备分离读取与输出

**问题**：步骤中混合"读文件"和"输出内容"时，模型读完文件后容易忘记输出（注意力被文件内容冲淡）。

**解法**：加 `## 前置准备` 阶段集中读取，正式步骤只消费已有信息。

```markdown
## 前置准备
1. 读取 xxx 了解规范
2. 读取 yyy 了解现状

准备完成后，依次执行以下步骤：

### 1. 输出 xxx（不再读文件，只管输出）
```

### 2. 输出锚点防跳步

**问题**：多步骤技能中，AI 容易合并多个步骤为一篇"综合回复"。开放式叙述步骤（如"用自己的话介绍"）尤其容易触发模式滑移，连带后续步骤一起被吞掉。

**解法**：给每个步骤加显式输出锚点。

- **结构化步骤**：开头加 `**先输出 "### 标题"，再开始执行。**`，强制产生输出打断合并倾向
- **开放式步骤**：提供输出模板（加粗小节标题），把"作文题"变成"填空题"

```markdown
# 反例（容易被跳过）
向用户介绍 docs/ 下三个目录的作用，用自己的话，结合项目实际。

# 正例（稳定输出）
必须输出以下三个小节（内容用自己的话，结合项目实际）：

**`docs/design/` — 设计方案（活文档）**
要点：...

**`docs/plans/` — 实施计划（执行清单）**
要点：...
```

### 3. 标题层级区分阶段

**问题**：前置准备和执行步骤使用相同标题层级（都是 `##`）时，模型难以区分阶段边界。

**解法**：前置准备用 `##`，执行步骤用 `###`，步骤内子节用 `####`。

### 4. 用 `@` 预加载替代运行时读取

**问题**：指令式"读取 xxx 文件"容易被模型跳过，尤其在上下文已经很长时。

**解法**：插件自带的静态文件用 `@` 声明式预加载，技能触发时内容自动注入上下文，不依赖模型主动读取。

- 技能同目录下的文件可用相对路径：`@references/workflow.md`
- 跨目录的文件用完整路径：`@${CLAUDE_PLUGIN_ROOT}/shared/conventions.md`
- 项目特定的动态文件（每个项目不同）仍用运行时读取

### 5. 用 Task 追踪强制步骤执行

**问题**：文字指令（"严格按顺序执行"、"不得跳过"）是软约束，模型在长上下文后容易忽略，导致步骤合并或跳步。

**解法**：用 TaskCreate 创建每个步骤的 task，逐个标记 in_progress → completed。工具调用是硬约束，模型必须显式调用才能推进。

```markdown
## 第一步：创建 Task 追踪

立即使用 TaskCreate 创建以下 task（不做任何文件读取）：
1. "步骤A" — activeForm: "执行步骤A"
2. "步骤B" — activeForm: "执行步骤B"

然后逐个执行（标记 in_progress → 执行 → 标记 completed）。
```

### 6. 读取就近原则

**问题**：集中前置读取多个文件后，文件内容冲淡后续执行指令的注意力。

**解法**：每个 task 只读取自己需要的文件，读完立刻使用。避免一次性读取所有文件。
